bl = 1/(cv_fit$best.lam1+cv_fit$best.lam2)
av = 2
bv = 3/100*crossprod(X%*%cv_fit$b-y)
bayes_fit = bayesFused(X,y,10000,w,av,bv,al,bl)
colMeans(bayes_fit$beta.post)
install.packages("HDTweedie")
install.packages("HDtweedie")
library(HDtweedie)
HDtweedie
tweediegrppath
.libPaths()
data(auto)
head(auto$y)
length(auto$y)
head(atuo$x)
head(auto$x)
dim(auto$x)
boxplot(auto$y~auto$x$GENDER,subset = )
auto$x$GENDER
auto@x$GENDER
auto$x[,53]
boxplot(auto$y~auto$x[,53],subset = auto$y>0)
colnames(auto$x)
boxplot(auto$y~auto$x[,53])
plot(auto$y~auto$x[,"AGE"])
temp = HDtweedie(auto$y, auto$x)
temp = HDtweedie(auto$x, auto$y)
temp
temp$lambda
temp$jerr
temp$beta
plot(auto$y~auto$x[,"REVOLKED"])
temp = cv.HDtweedie(auto$x, auto$y)
temp$lambda
temp$lambda.min
temp$HDtweedie.fit
gc()
source("bern_mcmc.R")
#########################
#Part (b)
set.seed(2384)
n = 100
p = 3
Ti = rep(20,n)
X = list()
for (i in 1:n) {
X[[i]] = cbind(1,rnorm(Ti[i],0.1,1),rnorm(Ti[i],1,sqrt(2)))
}
beta = c(0,1,-0.2)
vu = 2.89
u = rnorm(n, 0, vu)
source("~/Documents/mcgill/math680/assignment5/bern_mcmc.R")
set.seed(2384)
n = 100
p = 3
Ti = rep(20,n)
X = list()
for (i in 1:n) {
X[[i]] = cbind(1,rnorm(Ti[i],0.1,1),rnorm(Ti[i],1,sqrt(2)))
}
beta = c(0,1,-0.2)
vu = 2.89
u = rnorm(n, 0, vu)
y = list()
for (i in 1:n) {
y[[i]] = rbinom(Ti[i], 1, i.logit(X[[i]]%*%beta+u[i]))
}
y
test_post = bern_mcmc(X,y,10000,Ti,1.01,1.01,100)
beta
colMeans(test_post$beta.post)
vu
mean(test_post$vu.post)
sd(test_post$beta.post[,1:3])
beta_std_err = c(sd(test_post$beta.post[,1]),sd(test_post$beta.post[,2]),sd(test_post$beta.post[,3]))
beta_std_err
plot(cumsum(test_post$beta.post[,1])/(1:length(test_post$beta.post[,1])), type="l")
plot(cumsum(test_post$beta.post[,2])/(1:length(test_post$beta.post[,2])), type="l")
plot(cumsum(test_post$beta.post[,3])/(1:length(test_post$beta.post[,3])), type="l")
source('~/Documents/mcgill/math680/assignment5/bern_mcmc.R', echo=TRUE)
test_post = bern_mcmc(X,y,10000,Ti,1.01,1.01,100)
colMeans(test_post$beta.post)
plot(cumsum(test_post$beta.post[,1])/(1:length(test_post$beta.post[,1])), type="l")
plot(cumsum(test_post$beta.post[,2])/(1:length(test_post$beta.post[,2])), type="l")
plot(cumsum(test_post$beta.post[,3])/(1:length(test_post$beta.post[,3])), type="l")
beta
test_post = bern_mcmc(X,y,20000,Ti,1.01,1.01,100)
colMeans(test_post$beta.post)
plot(cumsum(test_post$beta.post[,1])/(1:length(test_post$beta.post[,1])), type="l")
beta
plot(cumsum(test_post$beta.post[,2])/(1:length(test_post$beta.post[,2])), type="l")
plot(cumsum(test_post$beta.post[,3])/(1:length(test_post$beta.post[,3])), type="l")
set.seed(233)
n2 = 100
p2 = 2
Ti = rep(15, n)
set.seed(233)
n2 = 100
p2 = 2
Ti = rep(15, n)
X = list()
for (i in 1:n) {
X[[i]] = cbind(1,rnorm(Ti[i],2,2),rnorm(Ti[i],-0.5,sqrt(3)))
}
X[[1]]
Ti
set.seed(2384)
n = 100
p = 3
Ti = rep(20,n)
X = list()
for (i in 1:n) {
X[[i]] = cbind(1,rnorm(Ti[i],0.1,1),rnorm(Ti[i],1,sqrt(2)))
}
X = list()
for (i in 1:n) {
X1[[i]] = cbind(1,rnorm(Ti[i],2,2),rnorm(Ti[i],-0.5,sqrt(3)))
}
X1 = list()
for (i in 1:n) {
X1[[i]] = cbind(1,rnorm(Ti[i],2,2),rnorm(Ti[i],-0.5,sqrt(3)))
}
X = list()
for (i in 1:n) {
X[[i]] = cbind(1,rnorm(Ti[i],0.1,1),rnorm(Ti[i],1,sqrt(2)))
}
set.seed(2384)
n = 100
p = 3
Ti = rep(20,n)
X = list()
for (i in 1:n) {
X[[i]] = cbind(1,rnorm(Ti[i],0.1,1),rnorm(Ti[i],1,sqrt(2)))
}
set.seed(233)
n2 = 100
p2 = 2
Ti2 = rep(15, n)
X2 = list()
for (i in 1:n) {
X2[[i]] = cbind(1,rnorm(Ti[i],2,2),rnorm(Ti[i],-0.5,sqrt(3)))
}
beta2 = c(1,2,-2)
vu2 = 1
u2 = rnorm(n, -1, vu)
set.seed(233)
n2 = 100
p2 = 2
Ti2 = rep(15, n2)
X2 = list()
for (i in 1:n2) {
X2[[i]] = cbind(1,rnorm(Ti2[i],2,2),rnorm(Ti2[i],-0.5,sqrt(3)))
}
beta2 = c(1,2,-2)
vu2 = 1
u2 = rnorm(n1, -1, vu)
y2 = list()
for (i in 1:n2) {
y2[[i]] = rbinom(Ti2[i], 1, i.logit(X2[[i]]%*%beta2+u2[i]))
}
beta2 = c(1,2,-2)
vu2 = 1
u2 = rnorm(n2, -1, vu)
y2 = list()
for (i in 1:n2) {
y2[[i]] = rbinom(Ti2[i], 1, i.logit(X2[[i]]%*%beta2+u2[i]))
}
y2
test_post2 = bern_mcmc(X2,y2,10000,Ti2,1.01,1.01,100)
colMeans(test_post2$beta.post)
beta2
plot(u2, colMeans(test_post2$u.post)); abline(0,1,col='red')
source("~/Documents/mcgill/math680/assignment5/bern_mcmc.R")
set.seed(2384)
n = 100
p = 3
Ti = rep(20,n)
X = list()
for (i in 1:n) {
X[[i]] = cbind(1,rnorm(Ti[i],0.1,1),rnorm(Ti[i],1,sqrt(2)))
}
beta = c(0,1,-0.2)
vu = 2.89
u = rnorm(n, 0, vu)
y = list()
for (i in 1:n) {
y[[i]] = rbinom(Ti[i], 1, i.logit(X[[i]]%*%beta+u[i]))
}
#Testing the mcmc function
test_post = bern_mcmc(X,y,10000,Ti,1.01,1.01,100)
beta_std_err = c(sd(test_post$beta.post[,1]),sd(test_post$beta.post[,2]),sd(test_post$beta.post[,3]))
save(test_post, beta_std_err, file="~/Documents/mcgill/math680/assignment5/dat_a5_q1c.RData")
beta_std_err
par(mfrow=c(3,1))
plot(cumsum(test_post$beta.post[,1])/(1:length(test_post$beta.post[,1])), type="l")
plot(cumsum(test_post$beta.post[,2])/(1:length(test_post$beta.post[,2])), type="l")
plot(cumsum(test_post$beta.post[,3])/(1:length(test_post$beta.post[,3])), type="l")
par(mfrow=c(3,1), mar=c(1,1,1,1))
plot(cumsum(test_post$beta.post[,1])/(1:length(test_post$beta.post[,1])), type="l")
plot(cumsum(test_post$beta.post[,2])/(1:length(test_post$beta.post[,2])), type="l")
plot(cumsum(test_post$beta.post[,3])/(1:length(test_post$beta.post[,3])), type="l")
par(mfrow=c(3,1), mar=c(1.5,1.5,1.5,1.5))
plot(cumsum(test_post$beta.post[,1])/(1:length(test_post$beta.post[,1])), type="l")
plot(cumsum(test_post$beta.post[,2])/(1:length(test_post$beta.post[,2])), type="l")
plot(cumsum(test_post$beta.post[,3])/(1:length(test_post$beta.post[,3])), type="l")
par(mfrow=c(3,1), mar=c(1.7,1.7,1.7,1.7))
plot(cumsum(test_post$beta.post[,1])/(1:length(test_post$beta.post[,1])), type="l")
plot(cumsum(test_post$beta.post[,2])/(1:length(test_post$beta.post[,2])), type="l")
plot(cumsum(test_post$beta.post[,3])/(1:length(test_post$beta.post[,3])), type="l")
par(mfrow=c(2,2))#, mar=c(1.7,1.7,1.7,1.7))
plot(cumsum(test_post$beta.post[,1])/(1:length(test_post$beta.post[,1])), type="l")
plot(cumsum(test_post$beta.post[,2])/(1:length(test_post$beta.post[,2])), type="l")
plot(cumsum(test_post$beta.post[,3])/(1:length(test_post$beta.post[,3])), type="l")
plot(cumsum(test_post$vu.post)/(1:length(test_post$vu.post)), type="l")
par(mfrow=c(2,2), mar=c(1.7,1.7,1.7,1.7))
plot(cumsum(test_post$beta.post[,1])/(1:length(test_post$beta.post[,1])), type="l")
plot(cumsum(test_post$beta.post[,2])/(1:length(test_post$beta.post[,2])), type="l")
plot(cumsum(test_post$beta.post[,3])/(1:length(test_post$beta.post[,3])), type="l")
plot(cumsum(test_post$vu.post)/(1:length(test_post$vu.post)), type="l")
par(mfrow=c(2,2), mar=rep(2,4))
plot(cumsum(test_post$beta.post[,1])/(1:length(test_post$beta.post[,1])), type="l")
plot(cumsum(test_post$beta.post[,2])/(1:length(test_post$beta.post[,2])), type="l")
plot(cumsum(test_post$beta.post[,3])/(1:length(test_post$beta.post[,3])), type="l")
plot(cumsum(test_post$vu.post)/(1:length(test_post$vu.post)), type="l")
plot(acf(rowMeans(test_post$beta.post)), main="Autocorrelation of mean of beta")
dev.off()
?acf
plot(acf(rowMeans(test_post$beta.post)), main="Autocorrelation of mean of beta", lag.max=1000)
plot(acf(rowMeans(test_post$vu.post)), main="Autocorrelation of mean of beta", lag.max=1000)
plot(acf(rowMeans(test_post$vu.post)), main="Autocorrelation of mean of beta", lag.max=1000)
set.seed(233)
n2 = 100
p2 = 2
Ti2 = rep(15, n2)
X2 = list()
for (i in 1:n2) {
X2[[i]] = cbind(1,rnorm(Ti2[i],2,2),rnorm(Ti2[i],-0.5,sqrt(3)))
}
beta2 = c(1,2,-2)
vu2 = 1
u2 = rnorm(n2, -1, vu)
y2 = list()
for (i in 1:n2) {
y2[[i]] = rbinom(Ti2[i], 1, i.logit(X2[[i]]%*%beta2+u2[i]))
}
#Testing the mcmc function
test_post2 = bern_mcmc(X2,y2,10000,Ti2,1.01,1.01,100)
par(mfrow=c(2,2), mar=rep(2,4))
plot(cumsum(test_post2$beta.post[,1])/(1:length(test_post2$beta.post[,1])), type="l")
plot(cumsum(test_post2$beta.post[,2])/(1:length(test_post2$beta.post[,2])), type="l")
plot(cumsum(test_post2$beta.post[,3])/(1:length(test_post2$beta.post[,3])), type="l")
plot(cumsum(test_post2$vu.post)/(1:length(test_post2$vu.post)), type="l")
save(test_post2, file="~/Documents/mcgill/math680/assignment5/dat_a5_q1d.RData")
source("~/Documents/mcgill/math680/assignment5/bayesFused.R")
source("~/Documents/mcgill/math680/assignment5/fusedRidge_crossval.R")
set.seed(9387)
n = 100; p = 5; v.star = 2
beta.star = c(1,1,0.75,0.5,0.5)
Sigma = matrix(0,p,p)
for (i in 1:p) {
for (j in 1:p) {
Sigma[i,j] = 0.7^abs(i-j)
}
}
Z1=matrix(qnorm(runif(n*p)), nrow=n, ncol=p)
eo1=eigen(Sigma, symmetric=TRUE)
Sigma.sqrt=eo1$vec %*% diag(eo1$val^0.5)%*%t(eo1$vec)
X = matrix(0,n,p) + Z1%*%Sigma.sqrt
y = qnorm(runif(n), X%*%beta.star, v.star)
#Doing 5-fold cross validation
lam = 10^(seq(-8,8,0.5))
cv_fit = cvfr(cbind(0,X), y, lam, lam, 5)
w = cv_fit$best.lam1/(cv_fit$best.lam1+cv_fit$best.lam2)
al = 2
bl = 1/(cv_fit$best.lam1+cv_fit$best.lam2)
av = 2
bv = 3/100*crossprod(X%*%cv_fit$b-y)
bayes_fit = bayesFused(X,y,10000,w,av,bv,al,bl)
bcred = matrix(0,5,2); colnames(bcred) = c("lower","upper")
bcred[1,] = quantile(bayes_fit$beta.post[,1], c(0.005,0.995))
bcred[2,] = quantile(bayes_fit$beta.post[,2], c(0.005,0.995))
bcred[3,] = quantile(bayes_fit$beta.post[,3], c(0.005,0.995))
bcred[4,] = quantile(bayes_fit$beta.post[,4], c(0.005,0.995))
bcred[5,] = quantile(bayes_fit$beta.post[,5], c(0.005,0.995))
beta_est = cbind(colMeans(bayes_fit$beta.post),bcred); colnames(beta_est) = c("estimate","lower","upper")
library(xtable)
xtable(beta_est)
beta_est = cbind(beta.star, colMeans(bayes_fit$beta.post),bcred); colnames(beta_est) = c("Truth","Estimate","Lower","Upper")
xtable(beta_est)
xtable(beta_est, digits = 4)
par(mfrow=c(2,2), mar=rep(2,4))
plot(cumsum(bayes_fit$beta.post[,1])/(1:length(bayes_fit$beta.post[,1])), type="l")
plot(cumsum(bayes_fit$beta.post[,2])/(1:length(bayes_fit$beta.post[,2])), type="l")
plot(cumsum(bayes_fit$beta.post[,3])/(1:length(bayes_fit$beta.post[,3])), type="l")
plot(cumsum(bayes_fit$beta.post[,4])/(1:length(bayes_fit$beta.post[,4])), type="l")
save(bayes_fit, file="~/Documents/mcgill/math680/assignment5/dat_a5_q2bii.RData")
plot(acf(rowMeans(bayes_fit$beta.post)), main="Autocorrelation of mean of beta")
dev.off()
plot(acf(rowMeans(bayes_fit$beta.post)), main="Autocorrelation of mean of beta")
sampleBeta = function(n, alpha, beta, b) {
if (b<=0 | b>=1) stop("b must be between 0 and 1")
if (alpha<=0) stop("alpha must be positive")
if (beta<=0) stop("beta must be positive")
#Initial value
val = 0.5
samp=rep(0,n)
for (i in 1:n) {
#Sample from trial distribution
new.val = runif(1, val-b, val+b)
#Generate unif(0,1)
U = runif(1)
#Get acceptance prob
if (U<acceptProb(val, new.val, alpha, beta)) {
val = new.val
}
samp[i] = val
}
return(samp)
}
#Helper function to get acceptance probability
acceptProb = function(x, y, alpha, beta) {
tmp = ifelse( y>0 & y<1, (y/x)^(alpha-1)*((1-y)/(1-x))^(beta-1), 0 )
return(min(1,tmp))
}
test1 = sampleBeta(10000, 2, 2, 0.5)
mean(test1)
acf(test1, main="Autocorrelation: Beta MH sampling alpha=2, beta=2", lag.max = 1000, col="darkgreen")
test2 = sampleBeta(10000, 5, 2, 0.5)
mean(test2)
acf(test2, main="Autocorrelation: Beta MH sampling alpha=5, beta=2", lag.max = 1000, col="darkgreen")
save(test1, test2, file="~/Documents/mcgill/math680/assignment5/dat_a5_q3.R")
par(mfrow=c(2,1), mar=c(3,3,3,3))
plot(cumsum(test1)/(1:length(test1)), type="l"); abline(h=0.5, col="red", lty=2, lwd=1.5)
plot(cumsum(test2)/(1:length(test2)), type="l"); abline(h=5/7, col="red", lty=2, lwd=1.5)
par(mfrow=c(2,1))
acf(test1, main="Autocorrelation: Beta MH sampling alpha=2, beta=2", lag.max = 1000, col="darkgreen")
acf(test2, main="Autocorrelation: Beta MH sampling alpha=5, beta=2", lag.max = 1000, col="darkgreen")
-Inf
-Inf*0
log(0.05)/log(0.95)
library(pcalg)
library(Rgraphviz)
library(SMPracticals)
## example data
data(mathmarks)
suffStat <- list(C=cor(mathmarks), n=nrow(mathmarks))
pc.fit <- pc(suffStat, indepTest=gaussCItest, p=ncol(mathmarks), alpha=0.005, verbose=TRUE)
plot(pc.fit, labels=colnames(mathmarks), main="Inferred DAG for mathmarks")
install.packages("SMPracticals")
library(SMPracticals)
data(mathmarks)
suffStat <- list(C=cor(mathmarks), n=nrow(mathmarks))
pc.fit <- pc(suffStat, indepTest=gaussCItest, p=ncol(mathmarks), alpha=0.005, verbose=TRUE)
plot(pc.fit, labels=colnames(mathmarks), main="Inferred DAG for mathmarks")
mouse.data <- readRDS("mouse_data.RDS")
var.names <- readRDS("variable_names.RDS")
mouse <- mouse.data[mouse.data$geno==0,5:26]
colnames(mouse) <- var.names$nam
getwd()
setwd("~/Documents/research/causal_challenge_repo/data/")
var.names <- readRDS("variable_names.RDS")
mouse <- mouse.data[mouse.data$geno==0,5:26]
mouse.data <- readRDS("mouse_data.RDS")
mouse <- mouse.data[mouse.data$geno==0,5:26]
colnames(mouse) <- var.names$nam
cor(mouse)
suffStat <- list(C=cor(mouse), n=nrow(mouse))
pc.fit <- pc(suffStat, indepTest=gaussCItest, p=ncol(mouse), alpha=0.005, verbose=TRUE)
plot(pc.fit, labels=seq(1:22), main="Inferred DAG for 22 phenotypic measurements", cex.lab = 2)
plot(pc.fit, labels=seq(1:22), main="Inferred DAG for 22 phenotypic measurements", cex.lab = 2, conservative=TRUE)
pc.fit <- pc(suffStat, indepTest=gaussCItest, p=ncol(mouse), alpha=0.005, verbose=TRUE, conservative = TRUE)
plot(pc.fit, labels=seq(1:22), main="Inferred DAG for 22 phenotypic measurements", cex.lab = 2)
pc.fit <- pc(suffStat, indepTest=gaussCItest, p=ncol(mouse), alpha=0.005, verbose=TRUE)
plot(pc.fit, labels=seq(1:22), main="Inferred DAG for 22 phenotypic measurements", cex.lab = 2)
mouse1 <- mouse[,-c(1,2)]
suffStat <- list(C=cor(mouse1), n=nrow(mouse1))
pc.fit <- pc(suffStat, indepTest=gaussCItest, p=ncol(mouse1), alpha=0.005, verbose=TRUE)
plot(pc.fit, labels=seq(3,22), main="Inferred DAG for 20 phenotypic measurements", cex.lab = 2)
mouse2 <- mouse[,which(colnames(mouse) %in% c("Neutrophil differential count","Lymphocyte differential count", "Monocyte differential count", "Eosinophil differential count", "Basophil differential count"))]
suffStat <- list(C=cor(mouse2), n=nrow(mouse2))
pc.fit <- pc(suffStat, indepTest=gaussCItest, p=ncol(mouse2), alpha=0.005, verbose=TRUE)
plot(pc.fit, labels=colnames(mouse2), main="Inferred DAG for 5 phenotypic measurements", cex.lab = 2)
dev.off()
mouse3 <- mouse.data[-which(mouse.data$geno %in% c("1796_1", "3621_1", "4045_1", "3803_1", "3887_1")),]
colnames(mouse3)[5:26] <- var.names$nam
mouse3 <- mouse3[,-c(1,4)]
mouse3$sex <- as.numeric(mouse3$sex)
mouse3$geno <- as.numeric(mouse3$geno)
suffStat <- list(C=cor(mouse3), n=nrow(mouse3))
pc.fit <- pc(suffStat, indepTest=gaussCItest, p=ncol(mouse3), alpha=0.005, verbose=TRUE)
plot(pc.fit, labels=c("sex", "geno", seq(1:22)), main="Inferred DAG for 22 phenotypic measurements", cex.lab = 2)
table(mouse.data$geno, mouse.data$sex)
var.names
lm(IMPC_HEM_004_001~geno, data=mouse.data)
summary(lm(IMPC_HEM_004_001~geno, data=mouse.data))
summary(lm(IMPC_HEM_004_001~geno+sex, data=mouse.data))
var.names
load("simulation_final.RData")
res_replace29 = cbind(res[,1],res_no29[,2],res[,3:5])
res_replace29
res
res_no29
gc()
library(mice)
library(Metrics)
# read data
mouse.data <- readRDS("mouse_data.rds")
# consider only complete observations: delete genotypes with missing values
full_mouse <- mouse.data[-which(mouse.data$geno %in% c("1796_1", "3621_1", "4045_1", "3803_1", "3887_1")),]
Nsimul = 100
res <- matrix(0, Nsimul, 5)
res_no29 <- matrix(0, Nsimul, 5)
colnames(res) = colnames(res_no29) = c("IMPC_HEM_027_001", "IMPC_HEM_029_001", "IMPC_HEM_031_001", "IMPC_HEM_034_001", "IMPC_HEM_038_001")
sim_geno = matrix("", Nsimul, 5)
wh_var_29 = which(colnames(full_mouse)=="IMPC_HEM_029_001")
# consider only complete observations: delete genotypes with missing values
full_mouse <- mouse.data[-which(mouse.data$geno %in% c("1796_1", "3621_1", "4045_1", "3803_1", "3887_1")),]
for(i in 1:Nsimul)
{
# temporary dataframe
temp <- full_mouse
# empty method vector
method <- c("", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "")
method_no29 <- c("", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "")
# randomly select phenotypes to be deleted
NAgeno <- sample(unique(temp$geno)[2:9], 5)
NAvar <- c("IMPC_HEM_027_001", "IMPC_HEM_029_001", "IMPC_HEM_031_001", "IMPC_HEM_034_001", "IMPC_HEM_038_001")
# save true values + delete in temp
true = list(IMPC_HEM_027_001=temp[temp$geno==NAgeno[1],NAvar[1]],
IMPC_HEM_029_001=temp[temp$geno==NAgeno[2],NAvar[2]],
IMPC_HEM_031_001=temp[temp$geno==NAgeno[3],NAvar[3]],
IMPC_HEM_034_001=temp[temp$geno==NAgeno[4],NAvar[4]],
IMPC_HEM_038_001=temp[temp$geno==NAgeno[5],NAvar[5]])
for (j in 1:5) {
temp[temp$geno == NAgeno[j],  colnames(temp) == NAvar[j]] <- NA
}
sim_geno[i,] = NAgeno
# create data frame with all variables to impute + predictors
impMICE <- as.data.frame(cbind(temp[,2:3], temp[,5:26]))
impMICE_no29 <- as.data.frame(cbind(temp[,2:3], temp[,c(5:(wh_var_29-1),(wh_var_29+1):26)]))
# column ids of variables with missing values
id <- which(colnames(impMICE) %in% NAvar)
id_no29 = which(colnames(impMICE_no29) %in% NAvar)
# method norm + pmm
method[id] <- "norm"
method_no29[id_no29] <- "norm"
# matrix to specify which preditors to use
pred <- matrix(0, nrow = ncol(impMICE), ncol = ncol(impMICE))
pred[id,] <- rep(1, ncol(impMICE))
diag(pred) <- rep(0, ncol(impMICE))
pred_no29 = pred[-wh_var_29,-wh_var_29]
# apply MICE
MICE <- mice(impMICE, m = 30, method = method, predictorMatrix = pred, printFlag = FALSE)
MICE_no29 <- mice(impMICE_no29, m = 30, method = method_no29, predictorMatrix = pred_no29, printFlag = FALSE)
# get predictions and compute mse
predic = predic_no29 = list(IMPC_HEM_027_001=NULL,IMPC_HEM_029_001=NULL,IMPC_HEM_031_001=NULL,
IMPC_HEM_034_001=NULL,IMPC_HEM_038_001=NULL)
mse = rep(0,5)
mse_no29 = rep(0,5)
imputed_mat = impMICE
for (j in 1:5) {
predic[[j]] = apply(MICE$imp[id[j]][[1]], 1, mean)
#Only have predictions for 4 vars for now
if (j!=2) {
k = ifelse(j==1,j,j-1)
predic_no29[[j]] = apply(MICE_no29$imp[id_no29[k]][[1]], 1, mean)
#Put imputed values back into data frame
imputed_mat[imputed_mat$geno==NAgeno[j],id[j]] = predic_no29[[j]]
}
mse[j] <- mse(actual = true[[j]], predicted = predic[[j]])
}
#Now, given the predictions for the other variables, predict var 29
lm_mod = lm(IMPC_HEM_029_001~., data=imputed_mat[!imputed_mat$geno %in% NAgeno,-2])
predic_no29[[2]] = predict(lm_mod, newdata=imputed_mat[imputed_mat$geno==NAgeno[2],])
for (j in 1:5) {
mse_no29[j] = mse(actual = true[[j]], predicted = predic_no29[[j]])
}
# save results
res[i, ] <- mse
res_no29[i, ] <- mse_no29
cat(i, "\n")
}
res_replace29 = cbind(res[,1],res_no29[,2],res[,3:5])
res_replace29
hist(res_replace29)
dev.off()
hist(res_replace29)
boxplot(res_replace29)
save(res, res_no29, res_replace29, sim_geno, file = "simulation_final.RData")
library(ggplot2)
rep(1:5,each = 100)
plot_data = data.frame(c(res_replace29[,1],res_replace29[,2],res_replace29[,3],res_replace29[,4],res_replace29[,5],),
rep(1:5,each = 100))
plot_data = data.frame(c(res_replace29[,1],res_replace29[,2],res_replace29[,3],res_replace29[,4],res_replace29[,5]),
rep(1:5,each = 100))
colnames(plot_data) = c("MSE", "Variable")
plot_data
colnames(plot_data) = c("MSE", "Imputed Variable")
head(plot_data)
colnames(plot_data) = c("MSE", "Variable")
gplot = ggplot(plot_data, aes(factor(Variable), MSE))
gplot+geom_violin()
gplot+geom_boxplot()
gplot+geom_violin(scale="count")
gplot+geom_boxplot()
gplot+geom_violin(scale="width")
gplot+geom_violin(scale="width", adjust=0.5)
gplot+geom_violin(scale="width", adjust=0.25)
gplot+geom_violin(scale="width", adjust=2)
gplot+geom_violin(scale="width", adjust=0.1)
gplot+geom_boxplot()
gc()
